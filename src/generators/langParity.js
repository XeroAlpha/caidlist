import AdmZip from 'adm-zip';
import { writeFileSync, readFileSync } from 'fs';
import lcs from 'node-lcs';
import { projectRoot, projectInfo, forEachObject } from '../util/common.js';

const MILLS_PER_DAY = 24 * 60 * 60 * 1000;

function buildLangLookupMap(baseMap, compareMap) {
    const lookupMap = {}; // Record<Source, Record<Translation, Array<LangID>>>
    forEachObject(baseMap, (source, langId) => {
        let lookup = lookupMap[source];
        if (!lookup) {
            lookupMap[source] = lookup = {};
        }
        const translation = compareMap[langId] || '';
        let langIds = lookup[translation];
        if (!langIds) {
            lookup[translation] = langIds = [];
        }
        langIds.push(langId);
    });
    return lookupMap;
}

function isTranslationsEqual(array1, array2) {
    const set1 = new Set(array1.map((e) => e.replace(/\s/g, '')));
    const set2 = new Set(array2.map((e) => e.replace(/\s/g, '')));
    return set1.size === set2.size && [...set1].every((e) => set2.has(e));
}

export function compareEditionLangs(options) {
    const { bedrockEditionLang, javaEditionLang, compareLangId, baseLangId } = options;
    const bedrockLangMap = buildLangLookupMap(bedrockEditionLang[baseLangId], bedrockEditionLang[compareLangId]);
    const javaLangMap = buildLangLookupMap(javaEditionLang[baseLangId], javaEditionLang[compareLangId]);
    const differences = [];
    forEachObject(bedrockLangMap, (bedrockLookup, source) => {
        if (source in javaLangMap) {
            const javaLookup = javaLangMap[source];
            const bedrockTranslations = Object.keys(bedrockLookup);
            const javaTranslations = Object.keys(javaLookup);
            if (!isTranslationsEqual(bedrockTranslations, javaTranslations)) {
                differences.push({
                    source,
                    bedrockLookup,
                    javaLookup
                });
            }
        }
    });
    return differences;
}

function findBestMatchTranslation(lookup, baseLangId) {
    let bestTranslation = '';
    let bestScore = -1;
    let bestLangId = '';
    forEachObject(lookup, (langIds, translation) => {
        langIds.forEach((langId) => {
            const lcsResult = lcs(baseLangId, langId);
            if (lcsResult.length > bestScore) {
                bestTranslation = translation;
                bestScore = lcsResult.length;
                bestLangId = langId;
            }
        });
    });
    return [bestTranslation, bestLangId];
}

export function writeLangParityPack(cx, options) {
    const { outputDifferenceFile, outputLangFile, outputPackFile, differences, overrideMap } = options;
    const langWithComment = {};
    const langLines = [`## This file is auto-generated by ${projectInfo.homepage}`];
    differences.forEach((e) => {
        const bedrockTranslations = Object.keys(e.bedrockLookup);
        bedrockTranslations.forEach((bedrockTranslation) => {
            const bedrockLangIds = e.bedrockLookup[bedrockTranslation];
            bedrockLangIds.forEach((bedrockLangId) => {
                const [bestTranslation, bestLangId] = findBestMatchTranslation(e.javaLookup, bedrockLangId);
                if (!isTranslationsEqual([bedrockTranslation], [bestTranslation])) {
                    let comment = bedrockTranslation;
                    if (bestLangId !== bedrockLangId) {
                        comment = `${bestLangId} ${comment}`;
                    }
                    langWithComment[bedrockLangId] = [bestTranslation, comment];
                }
            });
        });
    });
    if (overrideMap) {
        forEachObject(overrideMap, (overrideValue, overrideKey) => {
            if (overrideValue === '' && overrideKey.includes('*')) {
                const regexStr = overrideKey.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&').replace(/\\\*/g, '(.*)');
                const regex = new RegExp(regexStr, '');
                forEachObject(langWithComment, (v, k) => {
                    if (regex.test(k)) {
                        langWithComment[k] = [''];
                    }
                });
            } else {
                langWithComment[overrideKey] = [overrideValue];
            }
        });
    }
    forEachObject(langWithComment, (v, k) => {
        if (v[0].length) {
            if (v.length > 1) {
                langLines.push(`${k}=${v[0]}\t\t# ${v[1]}`);
            } else {
                langLines.push(`${k}=${v[0]}`);
            }
        }
    });
    const langFileContent = langLines.join('\r\n');
    if (outputDifferenceFile) {
        writeFileSync(outputDifferenceFile, JSON.stringify(differences, null, 4));
    }
    if (outputLangFile) {
        writeFileSync(outputLangFile, langFileContent);
    }
    if (outputPackFile) {
        const zip = new AdmZip();
        const versionArray = [
            ...cx.coreVersion
                .split('.')
                .map((e) => parseInt(e, 10))
                .slice(0, 2),
            Math.floor(Date.now() / MILLS_PER_DAY)
        ];
        const files = {
            'manifest.json': {
                format_version: 2,
                header: {
                    name: '基岩版翻译同步',
                    description: '同步 Java 版的部分翻译至基岩版',
                    uuid: 'c7131e28-d145-4da9-8c8f-53fbd79cc028',
                    version: versionArray,
                    min_engine_version: [1, 18, 0]
                },
                modules: [
                    {
                        description: '同步 Java 版的部分翻译至基岩版',
                        type: 'resources',
                        uuid: 'd0760044-a2c3-4d08-9870-0f90b0de7e0c',
                        version: versionArray
                    }
                ]
            },
            'pack_icon.png': readFileSync(`${projectRoot}/src/assets/lang_parity_pack_icon.png`),
            'texts/languages.json': ['zh_CN'],
            'texts/zh_CN.lang': langFileContent
        };
        files['contents.json'] = {
            content: Object.keys(files).map((path) => ({ path }))
        };
        forEachObject(files, (content, fileName) => {
            let contentStr = content;
            if (typeof content !== 'string' && !Buffer.isBuffer(content)) {
                contentStr = JSON.stringify(content);
            }
            zip.addFile(fileName, Buffer.from(contentStr, 'utf-8'));
        });
        writeFileSync(outputPackFile, zip.toBuffer());
    }
}
