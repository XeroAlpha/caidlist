const AdmZip = require("adm-zip");
const fs = require("fs");
const lcs = require("node-lcs");
const { projectInfo, forEachObject } = require("../util/common");

const MILLS_PER_DAY = 24 * 60 * 60 * 1000;

function buildLangLookupMap(baseMap, compareMap) {
    const lookupMap = {}; // Record<Source, Record<Translation, Array<LangID>>>
    forEachObject(baseMap, (source, langId) => {
        let lookup = lookupMap[source];
        if (!lookup) {
            lookupMap[source] = lookup = {};
        }
        const translation = compareMap[langId] || "";
        let langIds = lookup[translation];
        if (!langIds) {
            lookup[translation] = langIds = [];
        }
        langIds.push(langId);
    });
    return lookupMap;
}

function isTranslationsEqual(array1, array2) {
    const set1 = new Set(array1.map((e) => e.replace(/\s/g, "")));
    const set2 = new Set(array2.map((e) => e.replace(/\s/g, "")));
    return set1.size == set2.size && [...set1].every((e) => set2.has(e));
}

function compareEditionLangs(options) {
    const { bedrockEditionLang, javaEditionLang, compareLangId, baseLangId } = options;
    const bedrockLangMap = buildLangLookupMap(bedrockEditionLang[baseLangId], bedrockEditionLang[compareLangId]);
    const javaLangMap = buildLangLookupMap(javaEditionLang[baseLangId], javaEditionLang[compareLangId]);
    const differences = [];
    forEachObject(bedrockLangMap, (bedrockLookup, source) => {
        if (source in javaLangMap) {
            const javaLookup = javaLangMap[source];
            const bedrockTranslations = Object.keys(bedrockLookup);
            const javaTranslations = Object.keys(javaLookup);
            if (!isTranslationsEqual(bedrockTranslations, javaTranslations)) {
                differences.push({
                    source,
                    bedrockLookup,
                    javaLookup
                });
            }
        }
    });
    return differences;
}

function findBestMatchTranslation(lookup, baseLangId) {
    let bestTranslation = "",
        bestScore = -1,
        bestLangId = "";
    forEachObject(lookup, (langIds, translation) => {
        langIds.forEach((langId) => {
            const lcsResult = lcs(baseLangId, langId);
            if (lcsResult.length > bestScore) {
                bestTranslation = translation;
                bestScore = lcsResult.length;
                bestLangId = langId;
            }
        });
    });
    return [bestTranslation, bestLangId];
}

function writeLangParityPack(cx, options) {
    const { outputDifferenceFile, outputLangFile, outputPackFile, differences, overrideMap } = options;
    const langWithComment = {};
    const langLines = ["## This file is auto-generated by " + projectInfo.homepage];
    differences.forEach((e) => {
        const bedrockTranslations = Object.keys(e.bedrockLookup);
        bedrockTranslations.forEach((bedrockTranslation) => {
            const bedrockLangIds = e.bedrockLookup[bedrockTranslation];
            bedrockLangIds.forEach((bedrockLangId) => {
                const [bestTranslation, bestLangId] = findBestMatchTranslation(e.javaLookup, bedrockLangId);
                if (!isTranslationsEqual([bedrockTranslation], [bestTranslation])) {
                    let comment = bedrockTranslation;
                    if (bestLangId != bedrockLangId) {
                        comment = bestLangId + " " + comment;
                    }
                    langWithComment[bedrockLangId] = [bestTranslation, comment];
                }
            });
        });
    });
    if (overrideMap) {
        forEachObject(overrideMap, (v, k) => {
            if (v == "" && k.includes("*")) {
                const regexStr = k.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&").replace(/\\\*/g, "(.*)");
                const regex = new RegExp(regexStr, "");
                forEachObject(langWithComment, (v, k) => {
                    if (regex.exec(k)) {
                        langWithComment[k] = [""];
                    }
                });
            } else {
                langWithComment[k] = [v];
            }
        });
    }
    forEachObject(langWithComment, (v, k) => {
        if (v[0].length) {
            if (v.length > 1) {
                langLines.push(`${k}=${v[0]}\t\t# ${v[1]}`);
            } else {
                langLines.push(`${k}=${v[0]}`);
            }
        }
    });
    const langFileContent = langLines.join("\r\n");
    if (outputDifferenceFile) {
        fs.writeFileSync(outputDifferenceFile, JSON.stringify(differences, null, 4));
    }
    if (outputLangFile) {
        fs.writeFileSync(outputLangFile, langFileContent);
    }
    if (outputPackFile) {
        const zip = new AdmZip();
        const versionArray = [
            ...cx.coreVersion.split(".").map((e) => parseInt(e)).slice(0, 2),
            Date.now() / MILLS_PER_DAY
        ];
        const files = {
            "manifest.json": {
                format_version: 2,
                header: {
                    name: "基岩版翻译同步",
                    description: "同步 Java 版的部分翻译至基岩版",
                    uuid: "c7131e28-d145-4da9-8c8f-53fbd79cc028",
                    version: versionArray,
                    min_engine_version: [1, 18, 0]
                },
                modules: [
                    {
                        description: "同步 Java 版的部分翻译至基岩版",
                        type: "resources",
                        uuid: "d0760044-a2c3-4d08-9870-0f90b0de7e0c",
                        version: versionArray
                    }
                ]
            },
            "pack_icon.png": fs.readFileSync(__dirname + "/../assets/lang_parity_pack_icon.png"),
            "texts/languages.json": ["zh_CN"],
            "texts/zh_CN.lang": langFileContent
        };
        files["contents.json"] = {
            content: Object.keys(files).map((path) => ({ path }))
        };
        forEachObject(files, (content, fileName) => {
            if (typeof content != "string" && !Buffer.isBuffer(content)) {
                content = JSON.stringify(content);
            }
            zip.addFile(fileName, Buffer.from(content, "utf-8"));
        });
        fs.writeFileSync(outputPackFile, zip.toBuffer());
    }
}

module.exports = { compareEditionLangs, writeLangParityPack };
